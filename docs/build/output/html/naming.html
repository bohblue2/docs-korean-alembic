
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>명명 규칙의 중요성 &#8212; Alembic 1.0.8 documentation</title>
    <link rel="stylesheet" href="_static/nature_override.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/changelog.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx_paramlinks.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="색인" href="genindex.html" />
    <link rel="search" title="검색" href="search.html" />
    <link rel="next" title="Running &#34;Batch&#34; Migrations for SQLite and Other Databases" href="batch.html" />
    <link rel="prev" title="SQL 스크립트 생성(&#34;오프라인 모드&#34;)" href="offline.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="batch.html" title="Running &#34;Batch&#34; Migrations for SQLite and Other Databases"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="offline.html" title="SQL 스크립트 생성(&#34;오프라인 모드&#34;)"
             accesskey="P">이전</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Alembic 1.0.8 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-importance-of-naming-constraints">
<span id="tutorial-constraint-names"></span><h1>명명 규칙의 중요성<a class="headerlink" href="#the-importance-of-naming-constraints" title="제목 주소">¶</a></h1>
<p>언급할만한 중요한 주제는 제약 명명 규칙이다. 지금까지 살펴본 바와 같이 우리는 테이블과 컬럼을 추가하는 방법에 대해 살펴 보았다. 외래 키나 고유 한 제약 조건과 같은 제약 조건을 추가하거나 삭제하는 것과 같은 연산들은:ref:<cite>ops</cite>에 나열되어 있다.마이그레이션 스크립트에서 이러한 제한 조건을 참조하는 것은 이름으로되어 있지만 대부분의경우 이 이름은 제한 조건이 작성 될 때 사용중인 관계형 데이터베이스에 의해 생선된다.. 예를 들어 Postgresql에서 다음과 같은 두 개의 CREATE TABLE 문을 내 보낸 경우 다음과 같이 된다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="o">=&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">user_account</span> <span class="p">(</span><span class="nb">id</span> <span class="n">INTEGER</span> <span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">);</span>
<span class="n">CREATE</span> <span class="n">TABLE</span>
<span class="n">test</span><span class="o">=&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">user_order</span> <span class="p">(</span>
<span class="n">test</span><span class="p">(</span><span class="o">&gt;</span>   <span class="nb">id</span> <span class="n">INTEGER</span> <span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">,</span>
<span class="n">test</span><span class="p">(</span><span class="o">&gt;</span>   <span class="n">user_account_id</span> <span class="n">INTEGER</span> <span class="n">REFERENCES</span> <span class="n">user_account</span><span class="p">(</span><span class="nb">id</span><span class="p">));</span>
<span class="n">CREATE</span> <span class="n">TABLE</span>
</pre></div>
</div>
<p>방금 <code class="docutils literal notranslate"><span class="pre">user_order.user_account_id</span></code> 열에 적용한 참조를 삭제한다고 가정 한다. 어떻게 할 수 있나? 프롬프트에서 우리는 <code class="docutils literal notranslate"><span class="pre">ALTER</span> <span class="pre">TABLE</span> <span class="pre">&lt;tablename&gt;</span> <span class="pre">DROP</span> <span class="pre">CONSTRAINT</span> <span class="pre">&lt;constraint_name&gt;</span></code>을 사용 하거나, Alembic의  <a class="reference internal" href="ops.html#alembic.operations.Operations.drop_constraint" title="alembic.operations.Operations.drop_constraint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operations.drop_constraint()</span></code></a>을 사용할 수 있다. 그러나 이 두 함수 모두 이름이 필요하다. 이 제약 조건의 이름은 무엇인가?</p>
<p>여기에는 Postgresql 카탈로그 테이블을보고 알아낼 수 있는 이름이 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="o">=&gt;</span> <span class="n">SELECT</span> <span class="n">r</span><span class="o">.</span><span class="n">conname</span> <span class="n">FROM</span>
<span class="n">test</span><span class="o">-&gt;</span>  <span class="n">pg_catalog</span><span class="o">.</span><span class="n">pg_class</span> <span class="n">c</span> <span class="n">JOIN</span> <span class="n">pg_catalog</span><span class="o">.</span><span class="n">pg_namespace</span> <span class="n">n</span> <span class="n">ON</span> <span class="n">n</span><span class="o">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">relnamespace</span>
<span class="n">test</span><span class="o">-&gt;</span>  <span class="n">JOIN</span> <span class="n">pg_catalog</span><span class="o">.</span><span class="n">pg_constraint</span> <span class="n">r</span>  <span class="n">ON</span> <span class="n">c</span><span class="o">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">conrelid</span>
<span class="n">test</span><span class="o">-&gt;</span>  <span class="n">WHERE</span> <span class="n">c</span><span class="o">.</span><span class="n">relname</span><span class="o">=</span><span class="s1">&#39;user_order&#39;</span> <span class="n">AND</span> <span class="n">r</span><span class="o">.</span><span class="n">contype</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span>
<span class="n">test</span><span class="o">-&gt;</span> <span class="p">;</span>
             <span class="n">conname</span>
<span class="o">---------------------------------</span>
 <span class="n">user_order_user_account_id_fkey</span>
<span class="p">(</span><span class="mi">1</span> <span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p>위의 이름은 Alembic 또는 SQLAlchemy에서 만든 것이 아니다. <code class="docutils literal notranslate"><span class="pre">user_order_user_account_id_fkey</span></code>은 Postgresql에서 내부적으로 사용하는 명명 체계이다. 만약 이것을 사용하지 않으면 명명되지 않는다.</p>
<p>이 계획은 그렇게 복잡하지는 않다. 우리는 우리의 지식을 사용하여 <a class="reference internal" href="ops.html#alembic.operations.Operations.drop_constraint" title="alembic.operations.Operations.drop_constraint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operations.drop_constraint()</span></code></a> 호출 할 때 사용할 이름을 알기 원한다. 그러나 그게 좋은 생각인가? 예를 들어 오라클에서도 코드를 실행해야한다면 어떻게 되는가? 오라클은 확실히 아래와 같은 구성표를 사용한다. 맞는가? 그렇지 않다면 비슷한 것이다. 점검 해보라:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Oracle</span> <span class="n">Database</span> <span class="mi">10</span><span class="n">g</span> <span class="n">Express</span> <span class="n">Edition</span> <span class="n">Release</span> <span class="mf">10.2</span><span class="o">.</span><span class="mf">0.1</span><span class="o">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">Production</span>

<span class="n">SQL</span><span class="o">&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">user_account</span> <span class="p">(</span><span class="nb">id</span> <span class="n">INTEGER</span> <span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">);</span>

<span class="n">Table</span> <span class="n">created</span><span class="o">.</span>

<span class="n">SQL</span><span class="o">&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">user_order</span> <span class="p">(</span>
  <span class="mi">2</span>     <span class="nb">id</span> <span class="n">INTEGER</span> <span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">,</span>
  <span class="mi">3</span>     <span class="n">user_account_id</span> <span class="n">INTEGER</span> <span class="n">REFERENCES</span> <span class="n">user_account</span><span class="p">(</span><span class="nb">id</span><span class="p">));</span>

<span class="n">Table</span> <span class="n">created</span><span class="o">.</span>

<span class="n">SQL</span><span class="o">&gt;</span> <span class="n">SELECT</span> <span class="n">constraint_name</span> <span class="n">FROM</span> <span class="n">all_constraints</span> <span class="n">WHERE</span>
  <span class="mi">2</span>     <span class="n">table_name</span><span class="o">=</span><span class="s1">&#39;USER_ORDER&#39;</span> <span class="n">AND</span> <span class="n">constraint_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">);</span>

<span class="n">CONSTRAINT_NAME</span>
<span class="o">-----------------------------------------------------</span>
<span class="n">SYS_C0029334</span>
</pre></div>
</div>
<p>오, 우리는 그것이 ..... 더 심하다는 것을 알 수 있다. 오라클의 이름은 완전히 예측할 수없는 영숫자 코드이다. 따라서 이러한 이름을 모두 찾아야하므로 마이그레이션이 매우 어려울 수 있다.</p>
<p>이렇게 복잡한 이름을 찾아야하는(look-up) 해결책은 자신의 이름을 만드는 것이다. 이것은 수동으로하기는 쉽지만 지루한 일이다. 예를 들어 SQLAlchemy에 모델을 만들면 외래 키 제약 조건에 이름을 사용할 수 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span>

<span class="n">meta</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="n">user_account</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_account&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
              <span class="p">)</span>

<span class="n">user_order</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_order&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;user_order_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span>
                    <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user_account.id&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fk_user_order_id&#39;</span><span class="p">))</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>이것에는 몇 가지 단점이 있지만 충분히 간단하다. 첫 번째는 지루한 일입니다. 우리는 다음과 같은 모든 이름을 기억해야 할 필요가 있다. <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/constraints.html#sqlalchemy.schema.ForeignKey" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>는 말할 것도 없고, <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/constraints.html#sqlalchemy.schema.UniqueConstraint" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueConstraint</span></code></a>, <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/constraints.html#sqlalchemy.schema.CheckConstraint" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">CheckConstraint</span></code></a>, <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/constraints.html#sqlalchemy.schema.Index" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>, <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrimaryKeyConstraint</span></code></a>, 이 뿐만 아니라 우리가 이 모든 것들을 변경할 수 있고 따라서 모든 이름은 전역 적으로 고유해야할 수도 있다. 이 모든 노력에도 불구하고 우리가 명명 체계를 머리속에 염두하고 있을지라도 매회 수동으로 할 때 잘못되기 쉽다.</p>
<p>최악의 경우 수동으로 명명 된 제약 조건 (및 인덱스)은 더 이상 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.Column" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>에 <code class="docutils literal notranslate"><span class="pre">.unique=True</span></code>또는 <code class="docutils literal notranslate"><span class="pre">.index=True</span></code>와 같은 편리한 기능을 사용할 수 없다는 점이 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user_account</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_account&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>위의 <code class="docutils literal notranslate"><span class="pre">unique=True</span></code>플래그는 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/constraints.html#sqlalchemy.schema.UniqueConstraint" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueConstraint</span></code></a>를 만들지만 다시 명명되지 않는다. 이름을 지정하고 싶다면 수동으로 <code class="docutils literal notranslate"><span class="pre">unique=True</span></code>사용을 제한하고 아래와 같이 전체 제약 조건을 입력해야한다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user_account</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_account&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
                  <span class="n">UniqueConstraint</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;uq_user_account_name&#39;</span><span class="p">)</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>이 명명 작업에는 <strong>자동화 된 명명 규칙</strong> 을 사용하는 해결법이 있따. 몇 년 동안 SQLAlchemy는 명명 스키마를 만들기 위해 DDL 이벤트 사용을 장려했다. 특히 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/events.html#sqlalchemy.events.DDLEvents.after_parent_attach" title="(in SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">after_parent_attach()</span></code></a>이벤트는 Constraint 및 Index 객체가 부모 Table 객체와 연관되어질 때나, 테이블 및 관련 컬럼의 이름을 사용하면서 <code class="docutils literal notranslate"><span class="pre">.name</span></code>을 제약 조건에 할당할때 가로채기 좋은 이벤트이다.</p>
<p>그러나 SQLAlchemy 0.9.2에서 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">naming_convention</span></code>이벤트를 넘어새로운 기능을 사용하는 더 나은 방법이 있다. 여기서는 명명 스키마를 참조하여 사전을 명명 스키마에 전달하면서 새 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>객체를 만들 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">convention</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">&quot;ix&quot;</span><span class="p">:</span> <span class="s2">&quot;ix_</span><span class="si">%(column_0_label)s</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="s2">&quot;uq&quot;</span><span class="p">:</span> <span class="s2">&quot;uq_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(column_0_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="s2">&quot;ck&quot;</span><span class="p">:</span> <span class="s2">&quot;ck_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(constraint_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="s2">&quot;fk&quot;</span><span class="p">:</span> <span class="s2">&quot;fk_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(column_0_name)s</span><span class="s2">_</span><span class="si">%(referred_table_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="s2">&quot;pk&quot;</span><span class="p">:</span> <span class="s2">&quot;pk_</span><span class="si">%(table_name)s</span><span class="s2">&quot;</span>
<span class="p">}</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">naming_convention</span><span class="o">=</span><span class="n">convention</span><span class="p">)</span>
</pre></div>
</div>
<p>위와 같이 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>를 사용하여 모델을 정의 하면 주어진 명명 규칙 사전을 사용하여 모든 제약 조건과 색인의 이름을 제공한다.</p>
<div class="section" id="integration-of-naming-conventions-into-operations-autogenerate">
<span id="autogen-naming-conventions"></span><h2>작업에 이름 지정 규칙 통합, 자동 생성<a class="headerlink" href="#integration-of-naming-conventions-into-operations-autogenerate" title="제목 주소">¶</a></h2>
<p>Alembic 0.6.4부터는 명명 규칙 기능이 <a class="reference internal" href="ops.html#alembic.operations.Operations" title="alembic.operations.Operations"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operations</span></code></a>객체에 통합되어 있으므로 명명되지 않은 모든 제약 조건에 적용된다. autogenerate가 사용될 때 일반적으로 구성되는 매개 변수(<code class="docutils literal notranslate"><span class="pre">env.py</span></code>안에 있는) <code class="xref py py-paramref docutils literal notranslate"><span class="pre">MigrationsContext.configure.target_metadata</span></code>을 사용하여 명명 규칙이 <a class="reference internal" href="ops.html#alembic.operations.Operations" title="alembic.operations.Operations"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operations</span></code></a>에 전달 된다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in your application&#39;s model:</span>

<span class="n">meta</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">naming_convention</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;ix&quot;</span><span class="p">:</span> <span class="s2">&quot;ix_</span><span class="si">%(column_0_label)s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;uq&quot;</span><span class="p">:</span> <span class="s2">&quot;uq_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(column_0_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ck&quot;</span><span class="p">:</span> <span class="s2">&quot;ck_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(constraint_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;fk&quot;</span><span class="p">:</span> <span class="s2">&quot;fk_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(column_0_name)s</span><span class="s2">_</span><span class="si">%(referred_table_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pk&quot;</span><span class="p">:</span> <span class="s2">&quot;pk_</span><span class="si">%(table_name)s</span><span class="s2">&quot;</span>
      <span class="p">})</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

<span class="c1"># .. in your Alembic env.py:</span>

<span class="c1"># add your model&#39;s MetaData object here</span>
<span class="c1"># for &#39;autogenerate&#39; support</span>
<span class="kn">from</span> <span class="nn">myapp</span> <span class="k">import</span> <span class="n">mymodel</span>
<span class="n">target_metadata</span> <span class="o">=</span> <span class="n">mymodel</span><span class="o">.</span><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span>

<span class="c1"># ...</span>

<span class="k">def</span> <span class="nf">run_migrations_online</span><span class="p">():</span>

    <span class="c1"># ...</span>

    <span class="n">context</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span>
                <span class="n">target_metadata</span><span class="o">=</span><span class="n">target_metadata</span>
                <span class="p">)</span>
</pre></div>
</div>
<p>위와 같이 다음과 같은 지시어를 렌더링 할 때:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="s1">&#39;sometable&#39;</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">Boolean</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;q_bool&#39;</span><span class="p">)))</span>
</pre></div>
</div>
<p>부울 타입은 사용중인 백엔드가 네이티브 부울 유형을 지원하지 않는다고 가정하고 <code class="docutils literal notranslate"><span class="pre">&quot;ck_sometable_q_bool&quot;</span></code>이름으로 CHECK 제한 조건을 렌더링한다 .</p>
<p>또한 제약 조건이있는 op 지시문을 사용할 수 있으며 명명 규칙에 필요하지 않으면 이름을 지정하지 않아도 된다. <code class="docutils literal notranslate"><span class="pre">None</span></code>의 값은 알맞은 이름 지정 규칙을 따르는 이름으로변환된다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">upgrade</span><span class="p">():</span>
    <span class="n">op</span><span class="o">.</span><span class="n">create_unique_constraint</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;some_table&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>autogenerate은 마이그레이션 스크립트에서 제약 조건을 렌더링 할 때 일반적으로  완료된 이름으로 렌더링한다. 적어도 Alembic 0.6.4와 SQLAlchemy 0.9.4를 사용 한다면, 문자열이 이미 토큰 화되었음을 나타내는 특별한 지시어 <a class="reference internal" href="ops.html#alembic.operations.Operations.f" title="alembic.operations.Operations.f"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operations.f()</span></code></a>로 렌더링될 것이다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">upgrade</span><span class="p">():</span>
    <span class="n">op</span><span class="o">.</span><span class="n">create_unique_constraint</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="s1">&#39;uq_const_x&#39;</span><span class="p">),</span> <span class="s1">&#39;some_table&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>명명 규칙 기능에 대한 자세한 내용은 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/constraints.html#constraint-naming-conventions" title="(in SQLAlchemy v1.3)"><span>Configuring Constraint Naming Conventions</span></a>을 참조하십시오.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">명명 규칙의 중요성</a><ul>
<li><a class="reference internal" href="#integration-of-naming-conventions-into-operations-autogenerate">작업에 이름 지정 규칙 통합, 자동 생성</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>빠른 검색</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="바로 가기" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h4>이전 항목</h4>
  <p class="topless"><a href="offline.html"
                        title="이전 장">SQL 스크립트 생성(&quot;오프라인 모드&quot;)</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="batch.html"
                        title="다음 장">Running &quot;Batch&quot; Migrations for SQLite and Other Databases</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="batch.html" title="Running &#34;Batch&#34; Migrations for SQLite and Other Databases"
             >다음</a> |</li>
        <li class="right" >
          <a href="offline.html" title="SQL 스크립트 생성(&#34;오프라인 모드&#34;)"
             >이전</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Alembic 1.0.8 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2019, Mike Bayer.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>