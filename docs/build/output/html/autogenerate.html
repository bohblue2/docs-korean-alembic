
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>마이그레이션 자동 생성 &#8212; Alembic 1.0.8 documentation</title>
    <link rel="stylesheet" href="_static/nature_override.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/changelog.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx_paramlinks.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="색인" href="genindex.html" />
    <link rel="search" title="검색" href="search.html" />
    <link rel="next" title="SQL 스크립트 생성(&#34;오프라인 모드&#34;)" href="offline.html" />
    <link rel="prev" title="튜토리얼" href="tutorial.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="offline.html" title="SQL 스크립트 생성(&#34;오프라인 모드&#34;)"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="튜토리얼"
             accesskey="P">이전</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Alembic 1.0.8 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="auto-generating-migrations">
<h1>마이그레이션 자동 생성<a class="headerlink" href="#auto-generating-migrations" title="제목 주소">¶</a></h1>
<p>Alembic은 데이터베이스의 상태를 볼 수 있고 어플리케이션 안의 테이블 메타데이터에 대해 비교할 수 있으므로, 비교에 기반한 “확실한” 마이그레이션을 한다.  <code class="docutils literal notranslate"><span class="pre">alembic</span> <span class="pre">revision</span></code> 명령의 <code class="docutils literal notranslate"><span class="pre">—autogenerate</span></code> 옵션을 사용하면, 소위 <em>후보</em> 마이그레이션을 새로운 마이그레이션 파일에 배치한다.  필요에 따라 수동으로 재검토하고 수정한 다음, 일반적 방식으로 계속해서 진행한다.</p>
<p>자동생성을 사용하기 위해, 우선 <code class="docutils literal notranslate"><span class="pre">env.py</span></code>을 수정하여 타겟을 포함하고 있는 테이블 메타데이터 객체에 접근하도록 한다. 우리의 어플리케이션이 <code class="docutils literal notranslate"><span class="pre">myapp.mymodel</span></code> 안에 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.html#declarative-toplevel" title="(in SQLAlchemy v1.3)"><span class="xref std std-ref">declarative base</span></a>을 가진다고 가정해보자.  이 base는 데이터베이스를 정의하는 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.Table" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 객체를 담고 있는 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 객체를 포함한다.  이것이 <code class="docutils literal notranslate"><span class="pre">env.py</span></code> 안에 로드되고, 그 다음에 <code class="docutils literal notranslate"><span class="pre">target_metadata</span></code> 인자를 통해 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">EnvironmentContext.configure()</span></code></a>로 전달되었는지 확인한다.  일반 템플릿에서 사용되는 <code class="docutils literal notranslate"><span class="pre">env.py</span></code> 샘플 스크립트는 편의상 상단에서 변수 선언을 하며, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>로 대체한다.  다음과 같이 시작한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># add your model&#39;s MetaData object here</span>
<span class="c1"># for &#39;autogenerate&#39; support</span>
<span class="c1"># from myapp import mymodel</span>
<span class="c1"># target_metadata = mymodel.Base.metadata</span>
<span class="n">target_metadata</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<p>이렇게 변경한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myapp.mymodel</span> <span class="k">import</span> <span class="n">Base</span>
<span class="n">target_metadata</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">위의 예시는 <code class="docutils literal notranslate"><span class="pre">alembic</span> <span class="pre">init</span></code>을 통해 호출되었을 때 기본적으로 생성되는 것과 같은 <a href="#id1"><span class="problematic" id="id2">**</span></a>일반적 alembic env.py 템플릿**을 나타내며, <code class="docutils literal notranslate"><span class="pre">multidb</span></code>와 같이 특별한 용도의 템플릿이 아니다.  자동생성 메타데이터가 어디에 그리고 어떻게 만들어지는지에 대한 구체적인 안내는 직접 <code class="docutils literal notranslate"><span class="pre">env.py</span></code> 스크립트 안에 있는 소스 코드와 코멘트를 참고하라.</p>
</div>
<p>다시 스크립트를 보면, <code class="docutils literal notranslate"><span class="pre">run_migrations_online()</span></code>에서 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">EnvironmentContext.configure()</span></code></a>로 지시문이 전달된 것을 볼 수 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_migrations_online</span><span class="p">():</span>
    <span class="n">engine</span> <span class="o">=</span> <span class="n">engine_from_config</span><span class="p">(</span>
                <span class="n">config</span><span class="o">.</span><span class="n">get_section</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">config_ini_section</span><span class="p">),</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;sqlalchemy.&#39;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">connection</span><span class="p">:</span>
        <span class="n">context</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                    <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span>
                    <span class="n">target_metadata</span><span class="o">=</span><span class="n">target_metadata</span>
                    <span class="p">)</span>

        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">begin_transaction</span><span class="p">():</span>
            <span class="n">context</span><span class="o">.</span><span class="n">run_migrations</span><span class="p">()</span>
</pre></div>
</div>
<p>그 다음 <code class="docutils literal notranslate"><span class="pre">—autogenerate</span></code> 옵션과 함께 <code class="docutils literal notranslate"><span class="pre">alembic</span> <span class="pre">revision</span></code> 명령어를 사용할 수 있다.  <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">account</span></code> 테이블에 대한 정의를 포함하고 있고, 데이터베이스에는 없다고 가정하자.  다음과 같은 결과를 얻을 것이다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ alembic revision --autogenerate -m &quot;Added account table&quot;
INFO [alembic.context] Detected added table &#39;account&#39;
Generating /path/to/foo/alembic/versions/27c6a30d7c24.py...done
</pre></div>
</div>
<p>그 다음 <code class="docutils literal notranslate"><span class="pre">27c6a30d7c24.py</span></code> 파일을 보면 기본 마이그레이션이 이미 있는 것을 확인할 수 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;empty message</span>

<span class="sd">Revision ID: 27c6a30d7c24</span>
<span class="sd">Revises: None</span>
<span class="sd">Create Date: 2011-11-08 11:40:27.089406</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># revision identifiers, used by Alembic.</span>
<span class="n">revision</span> <span class="o">=</span> <span class="s1">&#39;27c6a30d7c24&#39;</span>
<span class="n">down_revision</span> <span class="o">=</span> <span class="kc">None</span>

<span class="kn">from</span> <span class="nn">alembic</span> <span class="k">import</span> <span class="n">op</span>
<span class="kn">import</span> <span class="nn">sqlalchemy</span> <span class="k">as</span> <span class="nn">sa</span>

<span class="k">def</span> <span class="nf">upgrade</span><span class="p">():</span>
    <span class="c1">### commands auto generated by Alembic - please adjust! ###</span>
    <span class="n">op</span><span class="o">.</span><span class="n">create_table</span><span class="p">(</span>
    <span class="s1">&#39;account&#39;</span><span class="p">,</span>
    <span class="n">sa</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">sa</span><span class="o">.</span><span class="n">Integer</span><span class="p">()),</span>
    <span class="n">sa</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">sa</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">50</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
    <span class="n">sa</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="n">sa</span><span class="o">.</span><span class="n">VARCHAR</span><span class="p">(</span><span class="mi">200</span><span class="p">)),</span>
    <span class="n">sa</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;last_transaction_date&#39;</span><span class="p">,</span> <span class="n">sa</span><span class="o">.</span><span class="n">DateTime</span><span class="p">()),</span>
    <span class="n">sa</span><span class="o">.</span><span class="n">PrimaryKeyConstraint</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1">### end Alembic commands ###</span>

<span class="k">def</span> <span class="nf">downgrade</span><span class="p">():</span>
    <span class="c1">### commands auto generated by Alembic - please adjust! ###</span>
    <span class="n">op</span><span class="o">.</span><span class="n">drop_table</span><span class="p">(</span><span class="s2">&quot;account&quot;</span><span class="p">)</span>
    <span class="c1">### end Alembic commands ###</span>
</pre></div>
</div>
<p>당연히, 마이그레이션은 실제로 아직 실행되기 전이다.  보통 <code class="docutils literal notranslate"><span class="pre">upgrade</span></code> 명령어를 통해서 한다.  마이그레이션 파일로 가서 필요에 따라 지시문을 조정할 뿐 아니라 생성/수정/삭제 사이의 명확한 데이터 변경에 종속된 다른 지시문을 추가할 수 있다.</p>
<div class="section" id="what-does-autogenerate-detect-and-what-does-it-not-detect">
<h2>자동생성에서 어떤 것이 감지하는가 (그리고 감지되지 <em>못</em> 하는가?)<a class="headerlink" href="#what-does-autogenerate-detect-and-what-does-it-not-detect" title="제목 주소">¶</a></h2>
<p>엄청나게 많은 Alembic 사용자 이슈의 대다수 것들은 어떤 종류의 변경 사항을 자동생성으로 확실하게 감지할 수 있고, 또는 감지할 수 없는지에 대한 주제와, 감지하는 파이썬 코드를 어떻게 렌더링하는지에 대한 것이다.    <a href="#id1"><span class="problematic" id="id2">**</span></a>자동생성은 완벽하게 만들어지지 않았다**는 점을 알아두는 것이 매우 중요하다.  자동생성으로 만들어진 <a href="#id3"><span class="problematic" id="id4">**</span></a>후보 마이그레이션**을 <em>항상</em> 직접 검토하고 수정하는 것이 중요하다.  이 기능은 계속 릴리즈 되면서 점점 더 종합적이 되고 에러가 없어지겠지만, 현재 상태에서의 한계를 항상 인지하고 있어야 한다.</p>
<p>자동생성으로 <a href="#id1"><span class="problematic" id="id2">**</span></a>감지**할 수 있는 것:</p>
<ul class="simple">
<li>테이블 추가, 삭제.</li>
<li>컬럼 추가, 삭제.</li>
<li>컬럼의 null 허용 상태 변경.</li>
<li>인덱스 및 명시적인 이름이 있는 고유 제약 사항의 기본적인 변경</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 0.6.1에 추가: </span>인덱스와 고유 제약 사항의 자동생성이 지원됨.</p>
</div>
<ul class="simple">
<li>외부 키 제약에 대한 기본적인 변경</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 0.7.1에 추가: </span>외부 키 제약 사항의 자동생성이 지원됨.</p>
</div>
<p>자동생성으로 <a href="#id1"><span class="problematic" id="id2">*</span></a>선택적으로 감지*될 수 있는 것:</p>
<ul class="simple">
<li>컬럼 타입의 변경. 만약 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.compare_type" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.compare_type</span></code></a> 매개변수를 <code class="docutils literal notranslate"><span class="pre">True</span></code> 또는 사용자 맞춤형의 호출 가능한 함수로 설정했다면, 컬럼 타입 변경을 감지할 것이다. 이 기능은 대부분의 경우에서 잘 작동하지만, 기본값으로는 작동 안하기 때문에 먼저 타겟 스키마에 대해 테스트해 볼 수 있다.  또한, 여기에 호출 가능한 것을 전달하여 사용에 맞게 변경할 수 있다; 자세한 것은 <a class="reference internal" href="#compare-types"><span class="std std-ref">타입 비교</span></a> 부분을 보라.</li>
<li>서버 기본값의 변경.  만약 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.compare_server_default" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.compare_server_default</span></code></a> 매개변수를 <code class="docutils literal notranslate"><span class="pre">True</span></code> 또는 사용자 맞춤형의 호출 가능한 함수로 설정했다면, 변경을 감지할 것이다. 이 기능은 간단한 케이스에서는 잘 작동하지만 항상 정확한 결과를 제공하지는 못한다.  실제로 Postgresql 백엔드는 데이터베이스에 대한 “감지”와 “메타데이터” 값을 동작시켜 동등성을 판별한다.  이 기능은 작동 안하는 것이 기본값이기 때문에 타겟 스키마에 먼저 테스트를 먼저 해볼 수 있다.  타입 비교와 마찬가지로, 여기에 호출 가능한 것을 전달하여 사용에 맞게 변경할 수 있다; 자세한 것은 이 기능의 문서를 보라.</li>
</ul>
<p>자동생성으로 <em>감지할 수 없는 것</em>:</p>
<ul class="simple">
<li>테이블 이름의 변경.  두 개의 다른 테이블의 추가/삭제하는 것으로 나올 것이며, 이름의 변경은 수동으로 해주어야 한다.</li>
<li>컬럼 이름의 변경.  테이블 이름의 변경처럼, 이름 변경과 전혀 동일하지 않은, 두 개의 컬럼의 추가/삭제로 감지된다.</li>
<li>익명으로 이름 붙여진 제약사항.  예를 들어 <code class="docutils literal notranslate"><span class="pre">UniqueConstraint(‘col1’,</span> <span class="pre">‘col2’,</span> <span class="pre">name=“my_name”)</span></code>처럼 제약사항에 이름을 붙인다.  제약사항에 자동으로 명명하는 스키마 설정 방법에 대한 배경은 <a class="reference internal" href="naming.html"><span class="doc">명명 규칙의 중요성</span></a> 부분을 보라.</li>
<li><a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/type_basics.html#sqlalchemy.types.Enum" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>와 같이 특별한 SQLAlchemy 타입이 ENUM을 직접적으로 지원하지 않는 백엔드에서 만들어졌을 때 - 왜냐하면 비지원 데이터베이스에서 이러한 타입의 표현, 즉 CHAR+ CHECK 제약 사항은 아무 종류의 CHAR + CHECK가 될 수 있기 때문이다.  SQLAlchemy가 이것이 실제 ENUM인지 추측하여 판별하도록 하는 것은 일반적으로 좋지 않다. 여기에 “추측” 함수를 구현하려면, <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/events.html#sqlalchemy.events.DDLEvents.column_reflect" title="(in SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sqlalchemy.events.DDLEvents.column_reflect()</span></code></a> 이벤트를 사용해 CHAR(또는 다른 대상 타입)가 반영됐을 때를 감지하고, 해당 타입의 의도를 알고 있는 경우 ENUM(또는 원하는 타입)으로 변경한다.  <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/events.html#sqlalchemy.events.DDLEvents.after_parent_attach" title="(in SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sqlalchemy.events.DDLEvents.after_parent_attach()</span></code></a>는 자동생성 프로세스 안에서 원하지 않는 CHECK 제약 사항을 가로막고 제거하기 위해서 사용할 수 있다.</li>
</ul>
<p>현재는 자동 생성으로 감지 못하지만, <strong>결국에는 감지해 낼 것</strong> :</p>
<ul class="simple">
<li>PRIMARY KEY, EXCLUDE, CHECK를 포함하는, 일부 독립된 제약 사항의 추가와 삭제는 지원되지 않을 수 있다; 이것들은 필수로 자동생성 감지 시스템 내에 구현되지 않고, SQLAlchemy 용어에 의해서도 지원되지 않을 수 있다.</li>
<li>시퀀스의 추가, 삭제 - 아직까지 구현되지 않음.</li>
</ul>
</div>
<div class="section" id="autogenerating-multiple-metadata-collections">
<h2>여러 메타데이터 콜렉션 자동생성<a class="headerlink" href="#autogenerating-multiple-metadata-collections" title="제목 주소">¶</a></h2>
<p>어플리케이션이 여러 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 콜렉션을 가지고 있다면 <code class="docutils literal notranslate"><span class="pre">target_metadata</span></code> 콜렉션은 시퀀스로 정의될 수 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myapp.mymodel1</span> <span class="k">import</span> <span class="n">Model1Base</span>
<span class="kn">from</span> <span class="nn">myapp.mymodel2</span> <span class="k">import</span> <span class="n">Model2Base</span>
<span class="n">target_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="n">Model1Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">Model2Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">]</span>
</pre></div>
</div>
<p><a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 콜렉션의 시퀀스는 자동생성 프로세스 중에 순서대로 참조된다.  각각의 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>는 반드시 <strong>고유한</strong> 테이블 키(예를 들어 “키”는 테이블의 이름과 스키마의 조합이다)를 포함해야 함을 인지하라; 만약 두 개의 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 객체가 동일한 스키마/이름 조합의 테이블을 담고 있다면, 에러가 발생한다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 0.9.0으로 변경: </span>이제 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.target_metadata" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.target_metadata</span></code></a> 매개변수에 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 객체의 시퀀스가 전달되어 여러 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 콜렉션의 자동 생성을 지원할 수 있다.</p>
</div>
</div>
<div class="section" id="comparing-and-rendering-types">
<h2>비교 및 렌더링 타입<a class="headerlink" href="#comparing-and-rendering-types" title="제목 주소">¶</a></h2>
<p>SQLAlchemy 부분과 및 사용자 정의 타입을 포함하여, 스크립트로 렌더링 될 매우 다양한 타입이 있다는 점에서 마이그레이션 스크립트에서 파이썬 기반의 타입 객체를 비교하고 렌더링하는 자동생성 동작의 영역은 많은 어려움을 가지고 있다.  몇 가지 옵션이 이러한 작업을 돕기 위하여 제공된다.</p>
<div class="section" id="controlling-the-module-prefix">
<span id="autogen-module-prefix"></span><h3>모듈 접두사 제어<a class="headerlink" href="#controlling-the-module-prefix" title="제목 주소">¶</a></h3>
<p>타입이 렌더링될 때, <a href="#id1"><span class="problematic" id="id2">**</span></a>모듈 접두사**를 이용해 생성되기 때문에, 비교적 적은 수의 임포트를 기반으로 가능하다. 접두어가 무엇인지에 대한 규칙은 테이터타입의 종류 뿐만 아니라 구성 설정을 바탕으로 한다.  예를 들어, Alembic이 SQLAlcehmy 타입을 렌더링할 때, 기본적으로 <code class="docutils literal notranslate"><span class="pre">sa.</span></code>를 가지고 타입 이름 앞에 접두사를 붙인다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;my_column&quot;</span><span class="p">,</span> <span class="n">sa</span><span class="o">.</span><span class="n">Integer</span><span class="p">())</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sa.</span></code> 접두사의 사용은 :paramref:<a href="#id1"><span class="problematic" id="id2">`</span></a>.EnvironmentContext.configure.sqlalchemy_module_prefix`의 값을 변경하는 것으로 제어가능하다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_migrations_online</span><span class="p">():</span>
    <span class="c1"># ...</span>

    <span class="n">context</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span>
                <span class="n">target_metadata</span><span class="o">=</span><span class="n">target_metadata</span><span class="p">,</span>
                <span class="n">sqlalchemy_module_prefix</span><span class="o">=</span><span class="s2">&quot;sqla.&quot;</span><span class="p">,</span>
                <span class="c1"># ...</span>
                <span class="p">)</span>

    <span class="c1"># ...</span>
</pre></div>
</div>
<p>어느 경우라도, <code class="docutils literal notranslate"><span class="pre">sa</span></code> 접두사, 또는 원하는 접두사는 <code class="docutils literal notranslate"><span class="pre">script.py.mako</span></code>의 임포트 부분에 포함되어 있어야 한다; 또한 이것은 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">sqlalchemy</span> <span class="pre">as</span> <span class="pre">sa</span></code>을 기본값으로 한다.</p>
<p>사용자 정의 유형, 즉, <a href="#id1"><span class="problematic" id="id2">``</span></a>sqlalchemy.``모듈 네임스페이스에 없는 어떠한 사용자가 변경 가능한 유형은, Alembic이 기본값으로 <a href="#id3"><span class="problematic" id="id4">**</span></a>사용자 정의 유형의 __module__의 값**을 사용할 것이다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;my_column&quot;</span><span class="p">,</span> <span class="n">myapp</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">MyCustomType</span><span class="p">())</span>
</pre></div>
</div>
<p>위와 같은 사용자 변경 가능한 타입을 위한 임포트는 수동으로든, <code class="docutils literal notranslate"><span class="pre">script.py.mako</span></code> 안에 추가해서든, 마이그레이션 내에 있어야 한다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 0.7.0으로 변경: </span>이제 사용자 정의 타입을 위한 기본 모듈 접두사 렌더링은 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.sqlalchemy_module_prefix" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">sqlalchemy_module_prefix</span></code></a>의 값을 사용하는 대신, 접두사를 검색하기 위한 유형의``__module__`` 속성의 사용한다.</p>
</div>
<p>위의 사용자 정의 타입은 <code class="docutils literal notranslate"><span class="pre">__module__~`\을</span> <span class="pre">직접적으로</span> <span class="pre">사용하여</span> <span class="pre">길고</span> <span class="pre">무거운</span> <span class="pre">이름을</span> <span class="pre">가지는데,</span> <span class="pre">이는</span> <span class="pre">많은</span> <span class="pre">타입을</span> <span class="pre">수용하기</span> <span class="pre">위하여</span> <span class="pre">수</span> <span class="pre">많은</span> <span class="pre">임포트가</span> <span class="pre">필요할</span> <span class="pre">것임을</span> <span class="pre">암시한다.</span>&#160; <span class="pre">이러한</span> <span class="pre">이유로,</span> <span class="pre">마이그레이션</span> <span class="pre">스크립트에서</span> <span class="pre">사용되는</span> <span class="pre">사용자</span> <span class="pre">정의</span> <span class="pre">유형은</span> <span class="pre">단일</span> <span class="pre">모듈에서</span> <span class="pre">사용할</span> <span class="pre">것을</span> <span class="pre">추천한다.</span> <span class="pre">이를</span> <span class="pre">``myapp.migration_types</span></code>로 부른다고 가정하자:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># myapp/migration_types.py</span>

<span class="kn">from</span> <span class="nn">myapp.models.utils.types</span> <span class="k">import</span> <span class="n">MyCustomType</span>
</pre></div>
</div>
<p>우선 <code class="docutils literal notranslate"><span class="pre">migration_types</span></code>에 대한 임포트를 <code class="docutils literal notranslate"><span class="pre">script.py.mako</span></code>에 추가할 수 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>from alembic import op
import sqlalchemy as sa
import myapp.migration_types
${imports if imports else &quot;&quot;}
</pre></div>
</div>
<p>그 다음 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.user_module_prefix" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.user_module_prefix</span></code></a> 옵션을 사용하여, 고정된 접두사를 제공하는 것으로 Alembic의 <code class="docutils literal notranslate"><span class="pre">__module__~</span></code> 사용을 오버라이드한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_migrations_online</span><span class="p">():</span>
    <span class="c1"># ...</span>

    <span class="n">context</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span>
                <span class="n">target_metadata</span><span class="o">=</span><span class="n">target_metadata</span><span class="p">,</span>
                <span class="n">user_module_prefix</span><span class="o">=</span><span class="s2">&quot;myapp.migration_types.&quot;</span><span class="p">,</span>
                <span class="c1"># ...</span>
                <span class="p">)</span>

    <span class="c1"># ...</span>
</pre></div>
</div>
<p>위에서 처럼, 이제 다음과 같은 마이그레이션을 할 것이다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;my_column&quot;</span><span class="p">,</span> <span class="n">myapp</span><span class="o">.</span><span class="n">migration_types</span><span class="o">.</span><span class="n">MyCustomType</span><span class="p">())</span>
</pre></div>
</div>
<p>이제, 부득이 하게 <code class="docutils literal notranslate"><span class="pre">MyCustomType``을</span> <span class="pre">어딘가로</span> <span class="pre">옮기기</span> <span class="pre">위하여</span> <span class="pre">어플리케이션을</span> <span class="pre">리팩터링</span> <span class="pre">할</span> <span class="pre">때,</span> <span class="pre">마이그레이션</span> <span class="pre">스크립트</span> <span class="pre">내의</span> <span class="pre">모든</span> <span class="pre">인스턴스를</span> <span class="pre">검색하고</span> <span class="pre">바꾸는</span> <span class="pre">대신</span> <span class="pre">``myapp.migration_types</span></code> 모듈만 수정하면 된다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 0.6.3에 추가: </span><a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.user_module_prefix" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.user_module_prefix</span></code></a>가 추가되었다.</p>
</div>
</div>
<div class="section" id="affecting-the-rendering-of-types-themselves">
<span id="autogen-render-types"></span><h3>타입 렌더링 시 영향을 주는 것<a class="headerlink" href="#affecting-the-rendering-of-types-themselves" title="제목 주소">¶</a></h3>
<p>파이썬 코드로 SQLAlchemy와 사용자 정의 타입의 생성자를 만들기 위한 Alembic의 방법은 일반적이고 오래된 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code>이다.  대부분의 SQLAlchemy에 내장된 타입은 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code>을 가지고 있는데, 이것은 파이썬으로 호환될 수 있는 생성자를 호출하여 정확하게 렌더링하지만, pickling 함수처럼 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code>로 호환될 수 없는 인자를 받는 생성자의 경우에는 예외적이다.</p>
<p>마이그레이션 스크립트로 렌더링되는 맞춤형 타입을 빌드할 때, 생성자를 제대로 만들 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code>을 해당 타입에 명시적으로 주는 것이 자주 있다.  이것은 보통 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.user_module_prefix" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.user_module_prefix</span></code></a>와 함께 결합해서 사용하면 충분하다.  하지만, 추가적인 동작이 필요하다면, 보다 더 포괄적인 훅으로 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.render_item</span> <span class="pre">옵션이</span> <span class="pre">있다.</span> <span class="pre">이</span> <span class="pre">훅은</span> <span class="pre">``env.py`</span></code> 안에서 모듈의 접두사를 포함하여 타입이 어떻게 렌더링되어야 하는지에 대한 모든 것을 맡아줄 호출 가능한 함수를 제공한다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">render_item</span><span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">autogen_context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply custom rendering for selected items.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s1">&#39;type&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MySpecialType</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;mypackage.</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">obj</span>

    <span class="c1"># default rendering for other objects</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">run_migrations_online</span><span class="p">():</span>
    <span class="c1"># ...</span>

    <span class="n">context</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span>
                <span class="n">target_metadata</span><span class="o">=</span><span class="n">target_metadata</span><span class="p">,</span>
                <span class="n">render_item</span><span class="o">=</span><span class="n">render_item</span><span class="p">,</span>
                <span class="c1"># ...</span>
                <span class="p">)</span>

    <span class="c1"># ...</span>
</pre></div>
</div>
<p>위의 예시에서는, <code class="docutils literal notranslate"><span class="pre">MySpecialType</span></code> 안에 <code class="docutils literal notranslate"><span class="pre">”%r”</span></code>에 대해 호출할 때 실행되는 적절한 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> 메소드를 포함하게 한다.</p>
<p>또한 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.render_item" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.render_item</span></code></a>을 위해 사용한 호출 가능한 함수로 마이그레이션 스크립트에 임포트를 추가할 수 있다. 전달된 <a class="reference internal" href="api/autogenerate.html#alembic.autogenerate.api.AutogenContext" title="alembic.autogenerate.api.AutogenContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutogenContext</span></code></a>는 <a class="reference internal" href="api/autogenerate.html#alembic.autogenerate.api.AutogenContext.imports" title="alembic.autogenerate.api.AutogenContext.imports"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AutogenContext.imports</span></code></a>로 호출된 데이터 멤버를 포함하는데, 이것은 새로운 임포트를 추가할 수 있는 파이썬 <code class="docutils literal notranslate"><span class="pre">set()</span></code>이다.  예를 들어, 만약 <code class="docutils literal notranslate"><span class="pre">MySpecialType</span></code>이 <code class="docutils literal notranslate"><span class="pre">mymodel.types</span></code>으로 불리는 모듈 안에 있고, ‘타입’을 만나면 임포트를 추가할 수 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">render_item</span><span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">autogen_context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply custom rendering for selected items.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s1">&#39;type&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MySpecialType</span><span class="p">):</span>
        <span class="c1"># add import for this type</span>
        <span class="n">autogen_context</span><span class="o">.</span><span class="n">imports</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;from mymodel import types&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;types.</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">obj</span>

    <span class="c1"># default rendering for other objects</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 0.8으로 변경: </span>호출 가능한 <code class="docutils literal notranslate"><span class="pre">render_item</span></code>에 전달된 <code class="docutils literal notranslate"><span class="pre">autoget_context</span></code> 데이터 멤버는 이제 <a class="reference internal" href="api/autogenerate.html#alembic.autogenerate.api.AutogenContext" title="alembic.autogenerate.api.AutogenContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutogenContext</span></code></a>의 인스턴스이다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 0.8.3으로 변경: </span>이 autogen context의 “임포트” 데이터 멤버는 attr:<cite>.AutogenContext.imports</cite>라는 새로운 <a class="reference internal" href="api/autogenerate.html#alembic.autogenerate.api.AutogenContext" title="alembic.autogenerate.api.AutogenContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutogenContext</span></code></a> 객체로 복원된다.</p>
</div>
<p>완료된 마이그레이션 스크립트는 <code class="docutils literal notranslate"><span class="pre">${imports}</span></code> 표현이 사용된 위치에 임포트를 포함할 것이고, 다음과 같은 결과를 만든다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">alembic</span> <span class="k">import</span> <span class="n">op</span>
<span class="kn">import</span> <span class="nn">sqlalchemy</span> <span class="k">as</span> <span class="nn">sa</span>
<span class="kn">from</span> <span class="nn">mymodel</span> <span class="k">import</span> <span class="n">types</span>

<span class="k">def</span> <span class="nf">upgrade</span><span class="p">():</span>
    <span class="n">op</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="s1">&#39;sometable&#39;</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;mycolumn&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MySpecialType</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="section" id="comparing-types">
<span id="compare-types"></span><h3>타입 비교<a class="headerlink" href="#comparing-types" title="제목 주소">¶</a></h3>
<p>기본 타입 비교 로직은 기본적인 사용자 정의 타입 뿐 아니라 타입으로 만들어진 SQLAlchemy에도 적용될 것이다.  이 로직은 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.compare_type" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.compare_type</span></code></a>의 매개변수가 참일 때 활성화된다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">context</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="c1"># ...</span>
    <span class="n">compare_type</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span>
</pre></div>
</div>
<p>그렇지 않고 특별한 사용자 정의 타입을 사용하는 경우, <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.compare_type" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.compare_type</span></code></a>의 매개변수로 사용자 정의 타입 비교 로직으로 구현하기 위해 사용될 수 있는 호출 가능한 함수를 받는다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_compare_type</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">inspected_column</span><span class="p">,</span>
            <span class="n">metadata_column</span><span class="p">,</span> <span class="n">inspected_type</span><span class="p">,</span> <span class="n">metadata_type</span><span class="p">):</span>
    <span class="c1"># return False if the metadata_type is the same as the inspected_type</span>
    <span class="c1"># or None to allow the default implementation to compare these</span>
    <span class="c1"># types. a return value of True means the two types do not</span>
    <span class="c1"># match and should result in a type change operation.</span>
    <span class="k">return</span> <span class="kc">None</span>

<span class="n">context</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="c1"># ...</span>
    <span class="n">compare_type</span> <span class="o">=</span> <span class="n">my_compare_type</span>
<span class="p">)</span>
</pre></div>
</div>
<p>위에서, <code class="docutils literal notranslate"><span class="pre">inspected_column</span></code>은 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/reflection.html#sqlalchemy.engine.reflection.Inspector.reflecttable" title="(in SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sqlalchemy.engine.reflection.Inspector.reflecttable()</span></code></a>이 반환하는 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.Column" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.schema.Column</span></code></a>이다. 반면 <code class="docutils literal notranslate"><span class="pre">metadata_column</span></code>은 로컬 모델 환경의 <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.Column" title="(in SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.schema.Column</span></code></a>이다.  <a href="#id1"><span class="problematic" id="id2">``</span></a>None``으로 반환된 값은 기본 타입 비교가 진행되었음을 나타낸다.</p>
<p>추가적으로, per-dialect와 같이 특수한 동작을 포함하는 임포트되거나 3rd party 패키지의 일부인 사용자 맞춤형 타입은 SQLAlchemy 타입에 대해 <code class="docutils literal notranslate"><span class="pre">compare_against_backend()</span></code>라는 메소드를 구현해야 한다.  만약 이 메소드가 존재한다면, True 또는 False를 반환 할 수 있는 곳에서 호출되어 타입이 동등한지 아닌지를 비교하도록 명시한다; 만약 None을 반환하면, 기본 타입 비교가 진행된 것이다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySpecialType</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>

    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">compare_against_backend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dialect</span><span class="p">,</span> <span class="n">conn_type</span><span class="p">):</span>
        <span class="c1"># return True if this type is the same as the given database type,</span>
        <span class="c1"># or None to allow the default implementation to compare these</span>
        <span class="c1"># types. a return value of False means the given type does not</span>
        <span class="c1"># match this type.</span>

        <span class="k">if</span> <span class="n">dialect</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;postgresql&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conn_type</span><span class="p">,</span> <span class="n">postgresql</span><span class="o">.</span><span class="n">UUID</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conn_type</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p class="last">Alembic은 아니면서 SQLAlchemy의 일부분인 위쪽의 <code class="docutils literal notranslate"><span class="pre">compare_against_backend</span></code> 메소드에 대한 불리언 반환값은 호출 가능한 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.compare_type" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.compare_type</span></code></a>와 <strong>정반대**인데, 동일한 타입일 때 ``True``을 반환하고 다른 타입이면 ``False``를 반환한다. 반면에 호출 가능한 :paramref:`.EnvironmentContext.configure.compare_type`은 타입이 **다른</strong> 경우에 <a href="#id1"><span class="problematic" id="id2">``</span></a>True``를 반환해야 한다.</p>
</div>
<p><a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.compare_type" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.compare_type</span></code></a>와 <code class="docutils literal notranslate"><span class="pre">compare_against_backend</span></code>를 구현하는 타입 자체 사이의 우선 순위는 <a class="reference internal" href="api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.compare_type" title="alembic.runtime.environment.EnvironmentContext.configure"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">EnvironmentContext.configure.compare_type</span></code></a>을 우선시 하는 것이 선호된다; 만약 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하면, 메타데이터 타입이 있을 경우, <cite>compare_against_backend`</cite> 메소드가 사용된다.  만약 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환되면, 타입 동등성에 대한 기본 검사가 실행된다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 0.7.6에 추가: </span>- added support for the <code class="docutils literal notranslate"><span class="pre">compare_against_backend()</span></code>
method.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">마이그레이션 자동 생성</a><ul>
<li><a class="reference internal" href="#what-does-autogenerate-detect-and-what-does-it-not-detect">자동생성에서 어떤 것이 감지하는가 (그리고 감지되지 <em>못</em> 하는가?)</a></li>
<li><a class="reference internal" href="#autogenerating-multiple-metadata-collections">여러 메타데이터 콜렉션 자동생성</a></li>
<li><a class="reference internal" href="#comparing-and-rendering-types">비교 및 렌더링 타입</a><ul>
<li><a class="reference internal" href="#controlling-the-module-prefix">모듈 접두사 제어</a></li>
<li><a class="reference internal" href="#affecting-the-rendering-of-types-themselves">타입 렌더링 시 영향을 주는 것</a></li>
<li><a class="reference internal" href="#comparing-types">타입 비교</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>빠른 검색</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="바로 가기" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h4>이전 항목</h4>
  <p class="topless"><a href="tutorial.html"
                        title="이전 장">튜토리얼</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="offline.html"
                        title="다음 장">SQL 스크립트 생성(&quot;오프라인 모드&quot;)</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="offline.html" title="SQL 스크립트 생성(&#34;오프라인 모드&#34;)"
             >다음</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="튜토리얼"
             >이전</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Alembic 1.0.8 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2019, Mike Bayer.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>